1. strategy pattern
1) 특징 : 다양한 객체클라이언트와 다양한 행동 그룹군들, 즉 바뀌는 부분이 캡슐화 되어 유연하게 활용할 수 있음
         클라이언트에서 어떤 객체를 사용할지 지정할 수 있다.
2) 장점 : 구현을 활용해서 유연함
         갭슐화로 기능군 관리가 편함 
         기능, 클라이언트 객체가 변경되어도 다른 부분에 영향이 없음
         실행중에 기능에 대한 변경이 가능
3) 단점 : 객체의 특징 (객체를 생성하는 클래스의 구성)인 상태(state)와 행동(method)을 기능군에서는 상태가 빠지고 기능(행동)만을 구현한거에 대해 객체라는 의미상의 문제가 생길 수 있다.
4) 활용 : 상황에 따라 최적의 알고리즘을 선택해서 사용하도록 할 때

2. adapter pattern
1) 특징 : 인터페이스를 클라이언트가 원하는 인터페이스로 바꿔주는 역할을 한다.
2) 장점 : 소스코드 변경없이 동작이 가능하도록 한다.
         어댑터 클래스에 새로운 기능을 추가해주는 등의 활용이 가능하다.
3) 단점 : 어댑터 클래스의 대부분의 코드를 구현해야 할 경우 효율적이지 못함.
4) 활용 : 기존 클래스를 사용하려고 하는데 인터페이스가 맞지 않을 경우

3. template method pattern
1) 특징 : 일반적인 클래스 상속 구조에서는 하위 클래스의 멤버 함수가 상위 클래스의 멤버 함수를 불러 사용하는 형태인데 반해 Template Method 패턴에서는 상위 클래스의 멤버 함수가 하위 클래스의 멤버 함수를 불러 사용하는 형태이다.
		 클래스 상속 관계를 이용해서 알고리즘의 일부를 변경시키는 방식
2) 장점 : 공통부분만 따로 빼내고 개별적으로 구현이 필요한 부분만 자식 클래스에서 구현하는 방식 가능
         일련의 알고리즘 단계를 캡슐화 함 
3) 단점 : 상속을 통하여 구현이 되므로 해당 추상 메서드가 필요한 클래스마다 상속을 받아야 한다.
4) 활용 : 일련의 알고리즘 단계 정의가 필요할 경우

4. factory method pattern
1) 특징 : 객체를 생성하되 직접 객체 생성자(Constructor)를 호출해서 객체를 생성하는 것이 아니라 대행 함수를 통해 간접적으로 객체를 생성하는 방식을 Factory Method 패턴이라고 한다. 또한 이때 객체 생성을 대행해주는 함수를 Factory Method라고 한다.
2) 장점 : 어떤 객체를 생성할 것인지와는 무관하게 동일한 형태로 프로그래밍이 가능하다. 
         직접 생성자를 호출해서 객체를 생성하는 것보다 훨씬 유연하고 확장성 있는 구조이다.
3) 단점 : 생성할 객체의 종류가 달라질때 마다 새로운 하위 클래스를 정의해야 한다. 이는 불필요하게 많은 클래스를 정의해야 한다는 문제점이 있다.
4) 활용 : 상속 관계에 있는 클래스들의 멤버 함수가 동일한 프로그램 로직을 가지고 있으면서 내부적으로 생성할 객체만 서로 다를 때 Factory Method 패턴을 적용하면 편리하다.

5. singleton pattern
1) 특징 : 하나의 프로그램 내에서 하나의 인스턴스만 사용하고자 할때.
2) 장점 : 시스템 자원을 효율적으로 사용할 수 있다.
3) 단점 : 여기 저기에서 참조되어서 변경되는 경우 문제 발생.
4) 활용 : 스레드풀, 디바이스 드라이버, 로그기록 용

6. prototype pattern
1) 특징 : 이미 생성된 객체를 복제(clone)해서 새로운 객체를 생성하는 방법.
2) 장점 : NEW 생성자를 호출할 경우 생성자 내의 코드를 전부 재 반복해야 하기 때문에 연산이 많아진다. 하지만 메모리를 복사하여 사용할 경우 그 과정을 줄일 수 있게 된다.
3) 단점 : 각 ConcretePrototype 클래스들이 각자 모두 Clone 함수를 구현해야 한다.
		 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy) 주의 필요.
4) 활용 : 인스턴스 생성이 어려운 경우(인스턴스화할 클래스를 런타임에 지정할 때, 동적 로딩)
	     어떤 클래스의 인스턴스를 만드는 것이 자원/시간을 많이 잡아먹거나 복잡 할 때
	     미리 원형으로 초기화해 두고, 나중에 이를 복제해서 사용하는 것이 매번 필요한 상태 조합의 값들을 수동적으로 초기화하는 것보다 편리 할 수도 있다.
	     
7. builder pattern
1) 특징 : 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴
2) 장점 : 클라이언트 코드는 작성이 쉽고, 가독성이 좋다.
         생성자처럼 빌더는 자신의 매개변수에 불변 규칙(invariants)을 적용할 수 있고 build 메소드는 그런 불변 규칙을 검사할 수 있다.
         여러 개의 가변인자(varargs) 매개변수를 가질 수 있다.
         유연성이 좋다. 하나의 빌더는 여러 개의 객체를 생성하는데 사용될 수 있으며, 이러한 과정 중에 빌더의 매개변수는 다양하게 조정될 수 있다.
3) 단점 : 어떤 객체를 생성하려면 우선 그것의 빌더를 생성해야 한다. 성능이 매우 중요한 상황에서는 문제가 될 수 있다.
4) 활용 : 생성자의 매개변수가 많을 경우

8. abstract factory pattern
1) 특징 : 객체를 생성함에 있어 객체를 구성하는 부분을 추상화 하여 여러 서브클래스가 상속/구현 받아서 객체를 구성하는 부분을 동일시 하는 방법.
2) 장점 : 클라이언트는 다만 AbstractFactory클래스와 AbstractProduct클래스들의 인터페이스만을 사용하면 된다. 
         이로써 클라이언트 소스코드는 객체가 생성되는 방식이나 과정 및 생성하는 종류가 변경되더라도 그 부분을 국지화될 수 있다
3) 단점 : 제품군의 개수가 늘어날수록 Concrete Factory클래스의 개수도 늘어나야 한다는 점이다. 따라서 제품군의 개수가 많아졌을 경우 클래스가 많아져 설계가 복잡해지게 된다.
         가장 큰 단점은 제품군에 새로운 제품이 추가되어야 할 경우, 모든 Factory 클래스를 수정해야 한다는 것이다.
4) 활용 : 다양한 구성 요소 별로 '객체의 집합'을 생성해야 할 때 유용.

9. bridge pattern
1) 특징 : 객체의 범용성을 증가시키기 위해 구현부를 비워놓고 객체의 생성시에 구현부를 입력을 받음
2) 장점 : 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있다.
3) 단점 : 디자인이 복잡해진다.
4) 활용 : 객체의 구현부를 다양하게 입력으로 받을 필요가 있는 경우

10. composite pattern
1) 특징 : 복합 개체(폴더)와 단일 개체(파일)를 같은 방법으로 사용하고자 할 때 사용되는 패턴
2) 장점 : 다양한 종류의 단일 개체 형식을 추가하는 것이 쉬우며, 클라이언트도 그것에 맞추어 간단해질 수 있다.
3) 단점 : 실제 개체 형식에서는 아무 필요도 없는 기능까지 기반 클래스에서 제공.
         시스템을 지나치게 일반화 함.
4) 활용 : 사용자에게 같은 방법으로 접근할 수 있게 투명성을 제공할 것인지 불필요한 행위를 제공하지 않음으로써 안정성을 택할 것인지는 개발자의 선택사항이다. 
         안정성보다 투명성을 제공하는 것이 이득이 많다고 판단되면 복합체 패턴을 사용.

11. decorator pattern
1) 특징 : 데코레이터를 사용하면 상속을 이용해 서브클래스를 만드는 경우에 비해 훨씬 유연하게 기능을 확장할 수 있다.
2) 장점 : 동적으로 추가되거나 변경되는 요인을 기존 코드를 수정하지 않고 변경할 수 있다.(OCP)
3) 단점 : 잡다한 클래스들이 너무 많아질 수 있다.
4) 활용 : 객체에 기존 코드 수정 없이 추가 요소를 동적으로 더할 필요가 있는 경우.

12. visitor pattern
1) 특징 : 개체를 구성하는 여러 요소(Task) 개체들에게 요소의 형식에 따라 수행할 구체적 작업을 방문자에 정의.
2) 장점 : 요소 형식에 따라 수행할 구체적 작업을 분리하여 구현할 수 있다는 장점과 새로운 연산을 요소 형식 변경 없이 가능하다.
3) 단점 : 결합도가 증가될 수 있다.
         요소의 형식이 추가되면 모든 방문자 형식에 추가된 요소 형식의 개체에 대한 연산을 추가해야 하는 비용이 발생하는 단점이 있다.
4) 활용 : 어떤 구조에 대해서 여러가지 기능을 구조는 변경하지 않으면서 추가시키고 싶을 때
         TotalHomeTask 뿐만 아니라 TotalHotelTask, TotalRestaurantTask등으로 내부에 특정 알고리즘을 개별 적용 가능
         
13. chain of responsibility pattern
1) 특징 : 한 요청을 처리할 수 있는 객체를 복수개로 둠으로써 객체 간의 결합도를 줄이고자 하는 디자인 패턴.
2) 장점 : 객체간의 느슨한 결합을 구현하며 객체의 책임이 모든 처리 객체에 분산된다.
3) 단점 : 모든 처리 객체를 순회 했음에도 적절한 처리 객체를 찾지 못할 경우가 발생할 수 있어 메시지 수신이 보장되지 않는다.
4) 활용 : 요청 처리를 책임질 객체를 명시하지 않은 채 요청의 처리를 하고 싶을 때
         요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

14. facade pattern
1) 특징 : 서브 시스템을 더 쉽게 사용할 수 있게 해주는 고수준 인터페이스를 제공.
2) 장점 : 최소지식원칙(Principle of Least Knowledge)
	     객체 사이의 상호작용은 될 수 있으면 줄이는 것이 좋다. 
3) 단점 : 퍼사드 클래스가 포함하려는 서브 시스템의 구성요소가 많으면 많아질수록 퍼사드 클래스 내부의 레퍼런스가 많아져서 복잡하다.
4) 활용 : 내부 절차가 복잡할 경우 이를 단순화 하고 싶을 때

15. observer pattern
1) 특징 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 정보가 갱신되는 1:N의 관계를 정의한다.
2) 장점 : 느슨한 결합(Loose coupling)
         옵저버는 언제든지 새로 추가할 수 있으며, 새로운 형식의 옵저버를 추가하려고 할 때도 주제를 전혀 변경할 필요가 없다.
3) 단점 : 자바의 Observable을 사용할 경우 인터페이스가 아닌 클래스로 구현되어 있어 다중상속에 제약이 있다.
4) 활용 : 하나의 객체가 여러개의 대상에 참조되는 경우 사용.(button click시 button에 의존하는 다른 객체들의 내용 등의 갱신이 필요할 때)

16. proxy pattern








